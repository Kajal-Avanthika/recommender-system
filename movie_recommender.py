# -*- coding: utf-8 -*-
"""Movie_recommender.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1m3nlfRCA4T7GPA9ZCW1qyVnngmhifRv8

## Interactive Movie Reccommender System

### Reading data with pandas
"""

import pandas as pd
import numpy as np
import sklearn
import matplotlib.pyplot as plot

movies = pd.read_csv("movies.csv")

movies

"""### Cleaning movie titles with regex"""

import re
# Defining a function to clean movie title
def clean_title(title):
  return re.sub("[^a-zA-Z0-9 ]", "", title)

# Creating a new column in the movies dataframe after cleaning
movies['clean_title'] = movies['title'].apply( lambda x: clean_title(x))
movies

"""### Creating a TFIDF matrix
Term frequency - Inverse Document Frequency
"""

from sklearn.feature_extraction.text import TfidfVectorizer
vectorizer = TfidfVectorizer(ngram_range = (1,2))
tfidf = vectorizer.fit_transform(movies['clean_title']) # The titles are converted to vectors

"""### Using cosine similarity"""

from sklearn.metrics.pairwise import cosine_similarity

def search_title(title):
  title = clean_title(title)
  query_vec = vectorizer.transform([title])
  similarity = cosine_similarity(query_vec,tfidf).flatten()
  indices = np.argpartition(similarity,-5)[-5:] # Selecting the last 5 movies, the top 5 movies which have max similarity
  results = movies.iloc[indices][::-1]
  return results

"""### Jupyter Notebook Widget"""

import ipywidgets as widgets
from IPython.display import display

movie_input = widgets.Text(
    value = 'Toy Story', # The default value
    description = 'Movie Title',
    disabled = False
)

movie_list = widgets.Output()

def on_type(data):
  with movie_list:
    movie_list.clear_output()
    title = data['new']
    if(len(title) > 5):
      display(search_title(title))

movie_input.observe(on_type,names = 'value')
display(movie_input,movie_list)

"""### Reading movie ratings data"""

ratings = pd.read_csv('ratings.csv')

ratings

ratings.dtypes

"""### Finding users who liked the same movie"""

given_movie_id = 2273

similar_users = ratings[(ratings["movieId"] == given_movie_id) & (ratings["rating"] >=5)]["userId"].unique()
# They watched the same movie as us and liked it

similar_users

similar_user_recs = ratings[(ratings["userId"].isin(similar_users)) & (ratings["rating"] >4)]["movieId"]
# Getting the similar users best rated movies

similar_user_recs

# Getting the movies that atleast 10% or more liked
similar_user_recs = similar_user_recs.value_counts()/len(similar_users)

similar_user_recs

similar_user_recs = similar_user_recs[similar_user_recs > 0.1] # Getting the movies which were rated as good by atleast 10% of the similar users

similar_user_recs

# Finding ratings of selected movies by ALL users
all_users = ratings[ (ratings['movieId'].isin(similar_user_recs.index)) & (ratings['rating'] >4)]
all_users

all_users_rec = all_users["movieId"].value_counts()/len (all_users["userId"].unique())

all_users_rec

"""### Creating a recommendation Score"""

comparision_percentages = pd.concat([similar_user_recs,all_users_rec], axis =1)
comparision_percentages.columns = ["similar","all"]
comparision_percentages

# We need movies that have huge difference b/w no.of ppl similar to us liked vs all the ppl who liked that movie

# Creating a recommendation score
comparision_percentages["score"] = comparision_percentages["similar"]/comparision_percentages["all"]

comparision_percentages

comparision_percentages = comparision_percentages.sort_values("score", ascending = False)

comparision_percentages

"""A higher score implies better recommendation"""

# Merging the datsets for the final movie recommendations
comparision_percentages.head(10).merge(movies,left_index = True, right_on = "movieId")

"""### Building a recommendation function"""

def watch_next(given_movie_id):
  similar_users = ratings[(ratings["movieId"] == given_movie_id) & (ratings["rating"] >=5)]["userId"].unique()
  similar_user_recs = ratings[(ratings["userId"].isin(similar_users)) & (ratings["rating"] >4)]["movieId"]
  similar_user_recs = similar_user_recs.value_counts()/len(similar_users)
  similar_user_recs = similar_user_recs[similar_user_recs > 0.1]
  # Finding how much movies all users like
  all_users = ratings[ (ratings['movieId'].isin(similar_user_recs.index)) & (ratings['rating'] >4)]
  all_users_rec = all_users["movieId"].value_counts()/len (all_users["userId"].unique())
  comparision_percentages = pd.concat([similar_user_recs,all_users_rec], axis =1)
  comparision_percentages.columns = ["similar","all"]
  comparision_percentages["score"] = comparision_percentages["similar"]/comparision_percentages["all"]
  comparision_percentages = comparision_percentages.sort_values("score", ascending = False)
  return comparision_percentages.head(10).merge(movies,left_index = True, right_on = "movieId")[["score", "title","genres"]]

watch_next(112)

"""### Creating an interactive recommendation widget"""

movie_input = widgets.Text(
    value = "Toy Story",
    description = "Movie Title:",
    disabled = False
)

recommendation_list = widgets.Output()

def on_type(data):
  with recommendation_list:
    recommendation_list.clear_output() # clearing the output screen
    title = data["new"]
    if(len(title) > 5):
      results = search_title(title) # Getting the movies similar to what the user typed out
      movie_id = results.iloc[0]["movieId"] # Grabbing the first most movieId that appears
      display(watch_next(movie_id))

movie_input.observe(on_type, names = "value")
display(movie_input,recommendation_list)